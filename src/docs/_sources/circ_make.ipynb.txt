{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# circ_make"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 概要"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "vscode": {
     "languageId": "plaintext"
    }
   },
   "source": [
    "この関数は与えられた情報からブロックエンコーディングの回路を自動的に組み上げる"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 引数一覧"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "|argument name|type|role|\n",
    "|---|---|---|\n",
    "|gate_inf|str|パウリ行列積の情報|\n",
    "|zero_one|list(elements:int)|制御ビットの状態に関する情報|\n",
    "|circ|QuantumCircuit(qulacs)|組み上げ先の回路|\n",
    "|qubit|int|量子回路に必要な総ビット数|\n",
    "|ancilla|int|量子回路に必要な補助ビット数|"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Python code"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "```python\n",
    "def circ_make(gate_inf, zero_one, circ, qubit, ancilla):\n",
    "    work_ope_order = []\n",
    "    input_switch = 0\n",
    "    input_ele = \"\"\n",
    "    if gate_inf == \"\":\n",
    "        gate_a = [[1., 0.],\n",
    "                  [0., 1.]]\n",
    "        for i in range(int(qubit - ancilla)):\n",
    "            gate = DenseMatrix(int(ancilla + i), gate_a)\n",
    "            mat_no = to_matrix_gate(gate)\n",
    "            for j in range(len(zero_one)):\n",
    "                cont_pos = len(zero_one) - j - 1\n",
    "                mat_no.add_control_qubit(cont_pos, zero_one[j])\n",
    "            circ.add_gate(mat_no)\n",
    "    else:\n",
    "        for i in range(len(gate_inf)):\n",
    "            if i < len(gate_inf) - 1.5:\n",
    "                if input_switch > 0.3:\n",
    "                    work_ope_order.append(input_ele)\n",
    "                    input_ele = \"\"\n",
    "                    input_switch = 0\n",
    "                if gate_inf[i+1] == \"X\":\n",
    "                    input_switch = 1\n",
    "                if gate_inf[i+1] == \"Y\":\n",
    "                    input_switch = 1\n",
    "                if gate_inf[i+1] == \"Z\":\n",
    "                    input_switch = 1\n",
    "                if gate_inf[i+1] == \"I\":\n",
    "                    input_switch = 1\n",
    "                input_ele += gate_inf[i]\n",
    "            else:\n",
    "                work_ope_order.append(input_ele)\n",
    "                input_switch = 0\n",
    "                work_ope_order[-1] += gate_inf[-1]\n",
    "        for i in range(len(work_ope_order)):\n",
    "            num_inf = \"\"\n",
    "            for j in range(len(work_ope_order[i])-1):\n",
    "                num_inf += work_ope_order[i][j+1]\n",
    "            tag_num = int(num_inf)\n",
    "            gate_pos = qubit - tag_num - 1\n",
    "            if work_ope_order[i][0] == \"X\":\n",
    "                gate_a = X(gate_pos)\n",
    "                mat_no = to_matrix_gate(gate_a)\n",
    "                for j in range(len(zero_one)):\n",
    "                    cont_pos = len(zero_one) - j - 1\n",
    "                    mat_no.add_control_qubit(cont_pos, \n",
    "                                             zero_one[j])\n",
    "            elif work_ope_order[i][0] == \"Y\":\n",
    "                gate_a = Y(gate_pos)\n",
    "                mat_no = to_matrix_gate(gate_a)\n",
    "                for j in range(len(zero_one)):\n",
    "                    cont_pos = len(zero_one) - j - 1\n",
    "                    mat_no.add_control_qubit(cont_pos, \n",
    "                                             zero_one[j])\n",
    "            elif work_ope_order[i][0] == \"Z\":\n",
    "                gate_a = Z(gate_pos)\n",
    "                mat_no = to_matrix_gate(gate_a)\n",
    "                for j in range(len(zero_one)):\n",
    "                    cont_pos = len(zero_one) - j - 1\n",
    "                    mat_no.add_control_qubit(cont_pos, \n",
    "                                             zero_one[j])\n",
    "            elif work_ope_order[i][0] == \"I\":\n",
    "                gate_a = [[1, 0],\n",
    "                          [0, 1]]\n",
    "                gate = DenseMatrix(int(gate_inf[2*i+1]), gate_a)\n",
    "                mat_no = to_matrix_gate(gate)\n",
    "                for j in range(len(zero_one)):\n",
    "                    cont_pos = len(zero_one) - j - 1\n",
    "                    mat_no.add_control_qubit(cont_pos, \n",
    "                                             zero_one[j])\n",
    "            circ.add_gate(mat_no)\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 実行例"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pitbe\n",
    "from qulacs import QuantumState, QuantumCircuit\n",
    "from qulacs.gate import X, Y, Z, DenseMatrix, to_matrix_gate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "circuit = QuantumCircuit(4)\n",
    "ope_lst = [\"I0I1\", \"X0X1\", \"Y0Y1\", \"Z0I1\"]\n",
    "cont_list = [[0, 0], [1, 0],\n",
    "             [0, 1], [1, 1]]\n",
    "\n",
    "for j in range(len(cont_list)):\n",
    "    pitbe.circ_make(ope_lst[j], cont_list[j], circuit, 4, 2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### 作成された回路図"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Quantum Circuit](./circuit_sample.jpeg)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 注意点"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "前述の通りこの関数には「qulacs」のクラスを一部用いているので\n",
    "必ず関数のimport部分で「qulacs」をimportすること\\\n",
    "また引数「zero_list」の値に説明時に触れたもの以外を\n",
    "代入した場合想定外の挙動をとる場合もある"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
